/*
Author: Fernando Zuher
Place: Brazil
Date: 24 June 2020
Book: The C programming language, second edition. Authors: BRIAN W KERNIGHAN and DENNIS M. RITCHIE.
About: Summary*, APPENDIX B - Standard Library

* Most of the text was drawn literally from the chapter.

PAGES 241 - 
PDF 255 - 

*/

The standard library is not part of the C language proper, but an environment that supports standard C will provide the function declarations and type and macro definitions of this library. We have omitted a few functions that are of limited utility or easily synthesized from others; we have omitted multi-byte characters; and we have omitted discussion of locale issues, that is, properties that depend on local language, nationality, or culture.

The functions, types and macros of the standard library are declared in standard headers:
<assert.h> <float.h> <math.h> <stdarg.h> <stdlib.h>
<ctype.h> <limits.h> <setjmp.h> <stddef.h> <string.h>
<errno.h> <locale.h> <signal.h> <stdio.h> <time.h>

A header can be accessed by
	#include <header>

Headers may be included in any order and any number of times. A header must be included outside of any external declaration or definition and before any use of anything it declares. A header need not be a source file.

External identifiers that begin with an underscore are reserved for use by the library, as are all other identifiers that begin with an underscore and an upper-case letter or another underscore.

B1. Input and Output: <stdio.h>
	The input and output functions, types, and macros defined in <stdio.h> represent nearly one third of the library.

	A stream is a source or destination of data that may be associated with a disk or other peripheral. The library supports text streams and binary streams, although on some systems, notably UNIX, these are identical. A text stream is a sequence of lines; each line has zero or more characters and is terminated by '\n'.

	A binary stream is a sequence of unprocessed bytes that record internal data, with the property that if it is written, then read back on the same system, it will compare equal.

	A stream is connected to a file or device by opening it; the connection is broken by closing the stream. Opening a file returns a pointer to an object of type FILE, which records whatever information is necessary to control the stream. We will use "file pointer" and "stream" interchangeably when there is no ambiguity.

	When a program begins execution, the three streams stdin, stdout, and stderr are already open.

	B1.1 File Operations
		
		The following functions deal with operations on files. The type size_t is the unsigned integral type produced by the sizeof operator.

		FILE *fopen(const char *filename, const char *mode)
			Filenames are limited to FILENAME_MAX characters. At most FOPEN_MAX files may be open at once.

		FILE *freopen(const char *filename, const char *mode, FILE *stream)

		int fflush(FILE *stream)
			fflush(NULL)

		int fclose(FILE *stream)

		int remove(const char *filename)

		int rename(const char *oldname, const char *newname)

		FILE *tmpfile(void)

		char *tmpnam(char s[L_tmpnam])
			tmpnam(NULL), L_tmpnam, TMP_MAX

		int setvbuf(FILE *stream, char *buf, int mode, size_t size)
			modes:
				_IOFBF: full buffering,
				_IOLBF: line buffering of text files,
				_IONBF: no buffering.
			If buf is not NULL, it will be used as the buffer; otherwise a buffer will be allocated.

		void setbuf(FILE *stream, char *buf)
		
	B1.2 Formatted Output

		The printf functions provide formatted output conversion.
		
		int fprintf(FILE *stream, const char *format, ...)

		%p: void *; print as a pointer (implementation-dependent representation).
		%n: int *; the number of characters written so far by this call to printf is written into the argument. No argument is converted.

		int printf(const char *format, ...)
			printf(...) is equivalent to fprintf(stdout, ...)

		int sprintf(char *s, const char *format, ...)

		vprintf(const char *format, va_list arg)
		vfprintf(FILE *stream, const char *format, va_list arg)
		vsprintf(char *s, const char *format, va_list arg)

	B1.3 Formatted Input

		The scanf functions deal with formatted input conversion.

		int fscanf(FILE *stream, const char *format, ...)

		%c: characters; char *. The next input characters are placed in the indicated array, up to the number given by the width field; the default is 1. No ' \0' is added. The normal skip over white space characters is suppressed in this case; to read the next non-white space character, use %1s.

		%p: pointer value as printed by printf("%p"); void *.
		
		%n: writes into the argument the number of characters read so far by this call; int *. No input is read. The converted item count is not incremented.

		[...]: matches the longest non-empty string of input characters from the set between brackets; char *. A '\0' is added. []...] includes ] in the set.

		[^...]: matches the longest non-empty string of input characters NOT from the set between brackets; char *. A '\0' is added. [^]...] includes ] in the set.

		int scanf(const char *format, ...)
			scanf(...) is identical to fscanf(stdin, ...).

		int sscanf(char *s, const char *format, ...)
			sscanf(s, ...) is equivalent to scanf(...) except that the input characters are taken from the string s.

	B1.4 Character Input and Output Functions

		int fgetc(FILE *stream)

		char *fgets(char *s, int n, FILE *stream)

		int fputc(int c, FILE *stream)

		int fputs(const char *s, FILE *stream)

		int getc(FILE *stream)
			getc is equivalent to fgetc except that if it is a macro, it may evaluate stream more than once.

		int getchar(void)
			getchar is equivalent to getc(stdin).

		char *gets(char *s)

		int putc(int c, FILE *stream)
			putc is equivalent to fputc except that if it is a macro, it may evaluate stream more than once.

		int putchar(int c)
			putchar(c) is equivalent to putc(c,stdout)

		int puts(const char *s)

		int ungetc(int c, FILE *stream)

	B1.5 Direct Input and Output Functions

		size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream)

		size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)

	B1.6 File Positioning Functions

		int fseek(FILE *stream, long offset, int origin)

		long ftell(FILE *stream)

		void rewind(FILE *stream)
			rewind(fp) is equivalent to fseek(fp, 0L, SEEK_SET); clearerr(fp).

		int fgetpos(FILE *stream, fpos_t *ptr)
			fgetpos records the current position of stream in *ptr, for subsequent use by fsetpos. The type fpos_t is suitable for recording such values. fgetpos returns non-zero on error.

		int fsetpos(FILE *stream, const fpos_t *ptr)
			fsetpos positions stream at the position recorded by fgetpos in *ptr. fsetpos returns non-zero on error.

	B1.7 Error Functions

		Many of the functions in the library set status indicators when error or end of file occur. These indicators may be set and tested explicitly. In addition, the integer expression errno (declared in <errno.h>) may contain an error number that gives further information about the most recent error.

		void clearerr(FILE *stream)
			clearerr clears the end of file and error indicators for stream.

		int feof(FILE *stream)
			feof returns non-zero if the end of file indicator for stream is set.

		int ferror(FILE *stream)
			ferror returns non-zero if the error indicator for stream is set.

		void perror(const char *s)
			
			perror(s) prints s and an implementation-defined error message corresponding to the integer in errno, as if by
				fprintf (stderr, "%s: %s\n", s, "error message")
			
			See strerror in Section B3.

B2. Character Class Tests: <ctype.h>

	The header <ctype.h> declares functions for testing characters. For each function, the argument is an int, whose value must be EOF or representable as an unsigned char, and the return value is an int. The functions return non-zero (true) if the argument c satisfies the condition described, and zero if not.

		isalnum(c)          isalpha(c) or isdigit(c) is true
		isalpha(c)          isupper(c) or islower(c) is true
		iscntrl(c)          control character
		isdigit(c)          decimal digit
		isgraph(c)          printing character except space
		islower(c)          lower-case letter
		isprint(c)          printing character including space
		ispunct(c)          printing character except space or letter or digit
		isspace(c)          space, formfeed, newline, carriage return, tab, vertical tab
		isupper(c)          upper-case letter
		isxdigit(c)         hexadecimal digit

	In the seven-bit ASCII character set, the printing characters are 0x20 (' ') to 0x7E ('~'); the control characters are 0 (NUL) to 0x1F (US), and 0x7F (DEL).
	
	In addition, there are two functions that convert the case of letters:
	int tolower(int c)     convert c to lower case
	int toupper(int c)     convert c to upper case

	If c is an upper-case letter, tolower(c) returns the corresponding lower-case letter; otherwise it returns c. If c is a lower-case letter, toupper(c) returns the corresponding upper-case letter; otherwise it returns c.

B3. String Functions: <string.h>

	There are two groups of string functions defined in the header <string.h>. The first have names beginning with str; the second have names beginning with mem.

	In the followingtable, variables sand t are of type char *; cs and ct are of type const char *; n is of type size_t; and c is an int converted to char.
		char *strcpy(s,ct)
		char *strncpy(s,ct,n)

		char *strcat(s,ct)
		char *strncat(s,ct,n)

		int strcmp(cs,ct)
		int strncmp(cs,ct,n)

		char *strchr(cs,c)
		char *strrchr(cs,c)

		size_t strspn(cs,ct)
		size_t strcspn(cs,ct)

		char *strpbrk(cs,ct)
		char *strstr(cs,ct)

		size_t strlen(cs)
		char *strerror(n)
		char *strtok(s,ct)

	The mem... functions are meant for manipulating objects as character arrays; the intent is an interface to efficient routines. In the following table, sand t are of type void *; cs and ct are of type const void *; n is of type size_ t; and c is an int converted to an unsigned char.
		void *memcpy(s,ct,n)
		void *memmove(s,ct,n)

		int memcmp(cs,ct,n)
		
		void *memchr(cs,c,n)
		void *memset(s,c,n)

B4. Mathematical Functions: <math.h>

	The header <math.h> declares mathematical functions and macros.
	The macros EDOM and ERANGE (found in <errno.h>) are non-zero integral constants that are used to signal domain and range errors for the functions; HUGE_VAL is a positive double value. A domain error occurs if an argument is outside the domain over which the function is defined. On a domain error, errno is set to EDOM; the return value is implementation-dependent. A range error occurs if the result of the function cannot be represented as a double. If the result overflows, the function returns HUGE_VAL with the right sign, and errno is set to ERANGE. If the result underflows, the function returns zero; whether errno is set to ERANGE is implementation-defined.

	In the following table, x and y are of type double, n is an int, and all functions return double. Angles for trigonometric functions are expressed in radians.
		sin(x)
		cos(x)
		tan(x)
		asin(x)
		acos(x)
		atan(x)
		atan2(y, x)
		sinh(x)
		cosh(x)
		tanh(x)
		exp(x)
		log(x)
		log10(x)
		pow(x,y)
		sqrt(x)
		ceil(x)
		floor(x)
		fabs(x)
		ldexp(x,n)
		frexp(x, int *exp)
		modf(x, double *ip)
		fmod(x, y)

	