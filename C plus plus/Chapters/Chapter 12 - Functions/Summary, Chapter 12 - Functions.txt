/*
Author: Fernando Zuher
Place: Brazil
Date: 22 June 2020
Book: The C++ Programming Language, fourth edition. Author: Bjarne Stroustrup.
About: Summary*, Chapter 12 - Functions
Pages: 305 - 3

* Most of the text was drawn literally from the chapter.

*/

12.1 Function Declarations

	A function declaration gives the name of the function, the type of the value returned (if any), and the number and types of the arguments that must be supplied in a call.

	A function declaration may contain argument names. This can be a help to the reader of a program, but unless the declaration is also a function definition, the compiler simply ignores such names.

	The type of a function consists of the return type and the argument types. For class member functions (§2.3.2, §16.2), the name of the class is also part of the function type. For example:
		
		double f(int i, const Info&); // type: double(int, const Info&)
		char& String::operator[](int); // type: char& String::(int)
		
	12.1.1 Why Functions?

		The most basic advice is to keep a function of a size so that you can look at it in total on a screen. Bugs tend to creep in when we can view only part of an algorithm at a time. For many programmers that puts a limit of about 40 lines on a function. My ideal is a much smaller size still, maybe an average of 7 lines.

		In essentially all cases, the cost of a function call is not a significant factor. Where that cost could be significant (e.g., for frequently used access functions, such as vector subscripting) inlining can eliminate it (§12.1.5). Use functions as a structuring mechanism.

	12.1.2 Parts of a Function Declaration
		
		In addition to specifying a name, a set of arguments, and a return type, a function declaration can contain a variety of specifiers and modifiers. In all we can have:
			• The name of the function; required
			• The argument list, which may be empty () ; required
			• The return type, which may be void and which may be prefix or suffix (using auto); required
			• inline, indicating a desire to have function calls implemented by inlining the function body (§12.1.5)
			• constexpr, indicating that it should be possible to evaluate the function at compile time if given constant expressions as arguments (§12.1.6)
			• noexcept, indicating that the function may not throw an exception (§13.5.1.1)
			• A linkage specification, for example, static (§15.2)
			• [[noreturn]], indicating that the function will not return using the normal call/return mechanism (§12.1.4)
		
		In addition, a member function may be specified as:
			• virtual, indicating that it can be overridden in a derived class (§20.3.2)
			• override, indicating that it must be overriding a virtual function from a base class (§20.3.4.1)
			• final, indicating that it cannot be overriden in a derived class (§20.3.4.2)
			• static, indicating that it is not associated with a particular object (§16.2.12)
			• const, indicating that it may not modify its object (§3.2.1.1, §16.2.9.1)

	12.1.3 Function Definitions

		A function definition is a function declaration in which the body of the function is presented.

		The definition and all declarations for a function must specify the same type. Unfortunately, to preserve C compatibility, a const is ignored at the highest level of an argument type. For example, this is two declarations of the same function:
		
			void f(int); // type is void(int)
			void f(const int); // type is void(int)
		
			ignored_const.cpp

		That function, f(), could be defined as:
			void f(int x) { /* we can modify x here */ }
		
		Alternatively, we could define f() as:
			void f(const int x) { /* we cannot modify x here */ }
		
		In either case, the argument that f() can or cannot modify is a copy of what a caller provided, so there is no danger of an obscure modification of the calling context.

		Function argument names are not part of the function type and need not be identical in different declarations. For example:
			int& max(int& a, int& b, int& c); // return a reference to the larger of a, b, and c
			
			int& max(int& x1, int& x2, int& x3)
			{
				return (x1>x2)? ((x1>x3)?x1:x3) : ((x2>x3)?x2:x3);
			}

		Naming arguments in declarations that are not definitions is optional and commonly used to simplify documentation. Conversely, we can indicate that an argument is unused in a function definition by not naming it. For example:

			void search(table∗ t, const char∗ key, const char∗)
			{
				// no use of the third argument
			}

			not_used_parameter.cpp
		
		Typically, unnamed arguments arise from the simplification of code or from planning ahead for extensions. In both cases, leaving the argument in place, although unused, ensures that callers are not affected by the change.

		In addition to functions, there are a few other things that we can call; these follow most rules defined for functions, such as the rules for argument passing (§12.2):
			• Constructors (§2.3.2, §16.2.5) are technicallly not functions; in particular, they don’t return a value, can initialize bases and members (§17.4), and can’t hav e their address taken.
			• Destructors (§3.2.1.2, §17.2) can’t be overloaded and can’t hav e their address taken.
			• Function objects (§3.4.3, §19.2.2) are not functions (they are objects) and can’t be overloaded, but their operator() s are functions.
			• Lambda expressions (§3.4.3, §11.4) are basically a shorthand for defining function objects.

	12.1.4 Returning Values

		Traditionally, in C and C++, the return type comes first in a function declaration (before the name of the function). However, a function declaration can also be written using a syntax that places the return type after the argument list. For example, the following two declarations are equivalent:
			
			string to_string(int a); // prefix return type
			auto to_string(int a) −> string; // suffix return type

			return_comes_after.cpp
		
		That is, a prefix auto indicates that the return type is placed after the argument list. The suffix return type is preceded by −>.
		
		The essential use for a suffix return type comes in function template declarations in which the return type depends on the arguments. For example:

			template<class T, class U>
			auto product(const vector<T>& x, const vector<U>& y) −> decltype(x∗y);
		
		However, the suffix return syntax can be used for any function. There is an obvious similarity between the suffix return syntax for a function and the lambda expression syntax (§3.4.3, §11.4); it is a pity those two constructs are not identical.

		A value must be returned from a function that is not declared void (however, main() is special; see §2.2.1).

		void f6() { return; } // OK

		A function that calls itself is said to be recursive.
		There can be more than one return-statement in a function.

		Like the semantics of argument passing, the semantics of function value return are identical to the semantics of copy initialization (§16.2.6).A return-statement initializes a variable of the returned type. The type of a return expression is checked against the type of the returned type, and all standard and user-defined type conversions are performed. For example:

			double f() { return 1; } // 1 is implicitly converted to double{1}

		Each time a function is called, a new copy of its arguments and local (automatic) variables is created. The store is reused after the function returns, so a pointer to a local non- static variable should never be returned. The contents of the location pointed to will change unpredictably:

			int∗ fp()
			{
				int local = 1;
				// ...
				return &local; // bad
			}
			
		An equivalent error can occur when using references:

			int& fr()
			{
				int local = 1;
				// ...
				return local; // bad
			}

		There are no void values. However, a call of a void function may be used as the return value of a void function. For example:
			void g(int∗ p);

			void h(int∗ p)
			{
				// ...
				return g(p); // OK: equivalent to ‘‘g(p); return;’’
			}
		This form of return is useful to avoid special cases when writing template functions where the return type is a template parameter.

		A function that does not return normally (i.e., through a return or ‘‘falling off the end’’) can be marked [[noreturn]] (§12.1.7).

			noreturn.cpp

	12.1.5 inline Functions

		A function can be defined to be inline. For example:
			inline int fac(int n)
			{
				return (n<2) ? 1 : n∗fac(n−1);
			}

		The inline specifier is a hint to the compiler that it should attempt to generate code for a call of fac() inline rather than laying down the code for the function once and then calling through the usual function call mechanism. A clever compiler can generate the constant 720 for a call fac(6). The possibility of mutually recursive inline functions, inline functions that recurse or not depending on input, etc., makes it impossible to guarantee that every call of an inline function is actually inlined. The degree of cleverness of a compiler cannot be legislated, so one compiler might generate 720, another 6∗fac(5), and yet another an un-inlined call fac(6). If you want a guarantee that a value is computed at compile time, declare it constexpr and make sure that all functions used in its evaluation are constexpr (§12.1.6).

		To make inlining possible in the absence of unusually clever compilation and linking facilities, the definition – and not just the declaration – of an inline function must be in scope (§15.2). An inline specifier does not affect the semantics of a function. In particular, an inline function still has a unique address, and so do static variables (§12.1.8) of an inline function.

	12.1.7 [[noreturn]] Functions

		A construct [[ ... ]] is called an attribute and can be placed just about anywhere in the C++ syntax. In general, an attribute specifies some implementation-dependent property about the syntactic entity that precedes it. In addition, an attribute can be placed in front of a declaration. There are only two standard attributes (§iso.7.6), and [[noreturn]] is one of them. The other is [[carries_dependency]] (§41.3).
		
		Placing [[noreturn]] at the start of a function declaration indicates that the function is not
		expected to return. For example:
			
			[[noreturn]] void exit(int); // exit will never return

		Knowing that a function does not return is useful for both comprehension and code generation.
		What happens if the function returns despite a [[noreturn]] attribute is undefined.

		noreturn.cpp

	12.1.8 Local Variables

		A static local variable allows the function to preserve information between calls without introducing a global variable that might be accessed and corrupted by other functions (see also §16.2.12).

		A static local variable is useful for avoiding order dependencies among nonlocal variables
		(§15.4.1).
	
		There are no local functions; if you feel you need one, use a function object or a lambda expression (§3.4.3, §11.4).
	
		The scope of a label (§9.6), should you be foolhardy enough to use one, is the complete func-
		tion, independent of which nested scope it may be in.

12.2 Argument Passing

	The semantics of argument passing are identical to the semantics of initialization (copy initialization, to be precise; §16.2.6). In particular, the type of an actual argument is checked against the type of the corresponding formal argument, and all standard and user-defined type conversions are performed. Unless a formal argument (parameter) is a reference, a copy of the actual argument is passed to the function.

	12.2.1 Reference Arguments

		Consider:
			void f(int val, int& ref)
			{
				++val;
				++ref;
			}
		When f() is called, ++val increments a local copy of the first actual argument, whereas ++ref
		increments the second actual argument. Consider:		
			void g()
			{
				int i = 1;
				int j = 1;
				f(i,j);
			}
		The call f(i,j) will increment j but not i. The first argument, i , is passed by value; the second argument, j, is passed by reference. As mentioned in §7.7, functions that modify call-by-reference arguments can make programs hard to read and should most often be avoided (but see §18.2.5). It can, however, be noticeably more efficient to pass a large object by reference than to pass it by value. In that case, the argument might be declared a const reference to indicate that the reference is used for efficiency reasons only and not to enable the called function to change the value of the object:
			void f(const Large& arg)
			{
				// the value of ‘‘arg’’ cannot be changed
				// (except by using explicit type conversion; §11.5)
			}

		The absence of const in the declaration of a reference argument is taken as a statement of intent to modify the variable:
			void g(Large& arg); // assume that g() modifies arg

		Similarly, declaring a pointer argument const tells readers that the value of an object pointed to by that argument is not changed by the function. For example:
			
			int strlen(const char∗); // number of characters in a C-style string
			char∗ strcpy(char∗ to, const char∗ from); // copy a C-style string
			int strcmp(const char∗, const char∗); // compare C-style strings
		
		The importance of using const arguments increases with the size of a program.

		How do we choose among the ways of passing arguments? My rules of thumb are:
			[1] Use pass-by-value for small objects.
			[2] Use pass-by- const -reference to pass large values that you don’t need to modify.
			[3] Return a result as a return value rather than modifying an object through an argument.
			[4] Use rvalue references to implement move (§3.3.2, §17.5.2) and forwarding (§23.5.2.1).
			[5] Pass a pointer if ‘‘no object’’ is a valid alternative (and represent ‘‘no object’’ by nullptr ).
			[6] Use pass-by-reference only if you have to.
		
		The ‘‘when you have to’’ in the last rule of thumb refers to the observation that passing pointers is often a less obscure mechanism for dealing with objects that need modification (§7.7.1, §7.7.4) than using references.

	12.2.2 Array Arguments

		