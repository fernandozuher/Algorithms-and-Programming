/*
Author: Fernando Zuher
Place: Brazil
Date: 22 June 2020
Book: The C++ Programming Language, fourth edition. Author: Bjarne Stroustrup.
About: Summary*, Chapter 12 - Functions
Pages: 305 - 3

* Most of the text was drawn literally from the chapter.

*/

12.1 Function Declarations

	A function declaration gives the name of the function, the type of the value returned (if any), and the number and types of the arguments that must be supplied in a call.

	A function declaration may contain argument names. This can be a help to the reader of a program, but unless the declaration is also a function definition, the compiler simply ignores such names.

	The type of a function consists of the return type and the argument types. For class member functions (§2.3.2, §16.2), the name of the class is also part of the function type. For example:
		
		double f(int i, const Info&); // type: double(int, const Info&)
		char& String::operator[](int); // type: char& String::(int)
		
	12.1.1 Why Functions?

		The most basic advice is to keep a function of a size so that you can look at it in total on a screen. Bugs tend to creep in when we can view only part of an algorithm at a time. For many programmers that puts a limit of about 40 lines on a function. My ideal is a much smaller size still, maybe an average of 7 lines.

		In essentially all cases, the cost of a function call is not a significant factor. Where that cost could be significant (e.g., for frequently used access functions, such as vector subscripting) inlining can eliminate it (§12.1.5). Use functions as a structuring mechanism.

	12.1.2 Parts of a Function Declaration
		
		In addition to specifying a name, a set of arguments, and a return type, a function declaration can contain a variety of specifiers and modifiers. In all we can have:
			• The name of the function; required
			• The argument list, which may be empty () ; required
			• The return type, which may be void and which may be prefix or suffix (using auto); required
			• inline, indicating a desire to have function calls implemented by inlining the function body (§12.1.5)
			• constexpr, indicating that it should be possible to evaluate the function at compile time if given constant expressions as arguments (§12.1.6)
			• noexcept, indicating that the function may not throw an exception (§13.5.1.1)
			• A linkage specification, for example, static (§15.2)
			• [[noreturn]], indicating that the function will not return using the normal call/return mechanism (§12.1.4)
		
		In addition, a member function may be specified as:
			• virtual, indicating that it can be overridden in a derived class (§20.3.2)
			• override, indicating that it must be overriding a virtual function from a base class (§20.3.4.1)
			• final, indicating that it cannot be overriden in a derived class (§20.3.4.2)
			• static, indicating that it is not associated with a particular object (§16.2.12)
			• const, indicating that it may not modify its object (§3.2.1.1, §16.2.9.1)

	12.1.3 Function Definitions

		A function definition is a function declaration in which the body of the function is presented.

		The definition and all declarations for a function must specify the same type. Unfortunately, to preserve C compatibility, a const is ignored at the highest level of an argument type. For example, this is two declarations of the same function:
		
			void f(int); // type is void(int)
			void f(const int); // type is void(int)
		
			ignored_const.cpp

		That function, f(), could be defined as:
			void f(int x) { /* we can modify x here */ }
		
		Alternatively, we could define f() as:
			void f(const int x) { /* we cannot modify x here */ }
		
		In either case, the argument that f() can or cannot modify is a copy of what a caller provided, so there is no danger of an obscure modification of the calling context.

		Function argument names are not part of the function type and need not be identical in different declarations. For example:
			int& max(int& a, int& b, int& c); // return a reference to the larger of a, b, and c
			
			int& max(int& x1, int& x2, int& x3)
			{
				return (x1>x2)? ((x1>x3)?x1:x3) : ((x2>x3)?x2:x3);
			}

		Naming arguments in declarations that are not definitions is optional and commonly used to simplify documentation. Conversely, we can indicate that an argument is unused in a function definition by not naming it. For example:

			void search(table∗ t, const char∗ key, const char∗)
			{
				// no use of the third argument
			}

			not_used_parameter.cpp
		
		Typically, unnamed arguments arise from the simplification of code or from planning ahead for extensions. In both cases, leaving the argument in place, although unused, ensures that callers are not affected by the change.

		In addition to functions, there are a few other things that we can call; these follow most rules defined for functions, such as the rules for argument passing (§12.2):
			• Constructors (§2.3.2, §16.2.5) are technicallly not functions; in particular, they don’t return a value, can initialize bases and members (§17.4), and can’t hav e their address taken.
			• Destructors (§3.2.1.2, §17.2) can’t be overloaded and can’t hav e their address taken.
			• Function objects (§3.4.3, §19.2.2) are not functions (they are objects) and can’t be overloaded, but their operator() s are functions.
			• Lambda expressions (§3.4.3, §11.4) are basically a shorthand for defining function objects.

	12.1.4 Returning Values

		Traditionally, in C and C++, the return type comes first in a function declaration (before the name of the function). However, a function declaration can also be written using a syntax that places the return type after the argument list. For example, the following two declarations are equivalent:
			
			string to_string(int a); // prefix return type
			auto to_string(int a) −> string; // suffix return type

			return_comes_after.cpp
		
		That is, a prefix auto indicates that the return type is placed after the argument list. The suffix return type is preceded by −>.
		
		The essential use for a suffix return type comes in function template declarations in which the return type depends on the arguments. For example:

			template<class T, class U>
			auto product(const vector<T>& x, const vector<U>& y) −> decltype(x∗y);
		
		However, the suffix return syntax can be used for any function. There is an obvious similarity between the suffix return syntax for a function and the lambda expression syntax (§3.4.3, §11.4); it is a pity those two constructs are not identical.

		A value must be returned from a function that is not declared void (however, main() is special; see §2.2.1).

		void f6() { return; } // OK

		A function that calls itself is said to be recursive.
		There can be more than one return-statement in a function.

		Like the semantics of argument passing, the semantics of function value return are identical to the semantics of copy initialization (§16.2.6).A return-statement initializes a variable of the returned type. The type of a return expression is checked against the type of the returned type, and all standard and user-defined type conversions are performed. For example:

			double f() { return 1; } // 1 is implicitly converted to double{1}

		Each time a function is called, a new copy of its arguments and local (automatic) variables is created. The store is reused after the function returns, so a pointer to a local non- static variable should never be returned. The contents of the location pointed to will change unpredictably:

			int∗ fp()
			{
				int local = 1;
				// ...
				return &local; // bad
			}
			
		An equivalent error can occur when using references:

			int& fr()
			{
				int local = 1;
				// ...
				return local; // bad
			}

		There are no void values. However, a call of a void function may be used as the return value of a void function. For example:
			void g(int∗ p);

			void h(int∗ p)
			{
				// ...
				return g(p); // OK: equivalent to ‘‘g(p); return;’’
			}
		This form of return is useful to avoid special cases when writing template functions where the return type is a template parameter.

		A function that does not return normally (i.e., through a return or ‘‘falling off the end’’) can be marked [[noreturn]] (§12.1.7).

			noreturn.cpp

	12.1.5 inline Functions

		A function can be defined to be inline. For example:
			inline int fac(int n)
			{
				return (n<2) ? 1 : n∗fac(n−1);
			}

		The inline specifier is a hint to the compiler that it should attempt to generate code for a call of fac() inline rather than laying down the code for the function once and then calling through the usual function call mechanism. A clever compiler can generate the constant 720 for a call fac(6). The possibility of mutually recursive inline functions, inline functions that recurse or not depending on input, etc., makes it impossible to guarantee that every call of an inline function is actually inlined. The degree of cleverness of a compiler cannot be legislated, so one compiler might generate 720, another 6∗fac(5), and yet another an un-inlined call fac(6). If you want a guarantee that a value is computed at compile time, declare it constexpr and make sure that all functions used in its evaluation are constexpr (§12.1.6).

		To make inlining possible in the absence of unusually clever compilation and linking facilities, the definition – and not just the declaration – of an inline function must be in scope (§15.2). An inline specifier does not affect the semantics of a function. In particular, an inline function still has a unique address, and so do static variables (§12.1.8) of an inline function.

	12.1.7 [[noreturn]] Functions

		A construct [[ ... ]] is called an attribute and can be placed just about anywhere in the C++ syntax. In general, an attribute specifies some implementation-dependent property about the syntactic entity that precedes it. In addition, an attribute can be placed in front of a declaration. There are only two standard attributes (§iso.7.6), and [[noreturn]] is one of them. The other is [[carries_dependency]] (§41.3).
		
		Placing [[noreturn]] at the start of a function declaration indicates that the function is not
		expected to return. For example:
			
			[[noreturn]] void exit(int); // exit will never return

		Knowing that a function does not return is useful for both comprehension and code generation.
		What happens if the function returns despite a [[noreturn]] attribute is undefined.

		noreturn.cpp

	12.1.8 Local Variables

		A static local variable allows the function to preserve information between calls without introducing a global variable that might be accessed and corrupted by other functions (see also §16.2.12).

		A static local variable is useful for avoiding order dependencies among nonlocal variables
		(§15.4.1).
	
		There are no local functions; if you feel you need one, use a function object or a lambda expression (§3.4.3, §11.4).
	
		The scope of a label (§9.6), should you be foolhardy enough to use one, is the complete func-
		tion, independent of which nested scope it may be in.

12.2 Argument Passing

	The semantics of argument passing are identical to the semantics of initialization (copy initialization, to be precise; §16.2.6). In particular, the type of an actual argument is checked against the type of the corresponding formal argument, and all standard and user-defined type conversions are performed. Unless a formal argument (parameter) is a reference, a copy of the actual argument is passed to the function.

	12.2.1 Reference Arguments

		Consider:
			void f(int val, int& ref)
			{
				++val;
				++ref;
			}
		When f() is called, ++val increments a local copy of the first actual argument, whereas ++ref
		increments the second actual argument. Consider:		
			void g()
			{
				int i = 1;
				int j = 1;
				f(i,j);
			}
		The call f(i,j) will increment j but not i. The first argument, i , is passed by value; the second argument, j, is passed by reference. As mentioned in §7.7, functions that modify call-by-reference arguments can make programs hard to read and should most often be avoided (but see §18.2.5). It can, however, be noticeably more efficient to pass a large object by reference than to pass it by value. In that case, the argument might be declared a const reference to indicate that the reference is used for efficiency reasons only and not to enable the called function to change the value of the object:
			void f(const Large& arg)
			{
				// the value of ‘‘arg’’ cannot be changed
				// (except by using explicit type conversion; §11.5)
			}

		The absence of const in the declaration of a reference argument is taken as a statement of intent to modify the variable:
			void g(Large& arg); // assume that g() modifies arg

		Similarly, declaring a pointer argument const tells readers that the value of an object pointed to by that argument is not changed by the function. For example:
			
			int strlen(const char∗); // number of characters in a C-style string
			char∗ strcpy(char∗ to, const char∗ from); // copy a C-style string
			int strcmp(const char∗, const char∗); // compare C-style strings
		
		The importance of using const arguments increases with the size of a program.

		How do we choose among the ways of passing arguments? My rules of thumb are:
			[1] Use pass-by-value for small objects.
			[2] Use pass-by- const -reference to pass large values that you don’t need to modify.
			[3] Return a result as a return value rather than modifying an object through an argument.
			[4] Use rvalue references to implement move (§3.3.2, §17.5.2) and forwarding (§23.5.2.1).
			[5] Pass a pointer if ‘‘no object’’ is a valid alternative (and represent ‘‘no object’’ by nullptr ).
			[6] Use pass-by-reference only if you have to.
		
		The ‘‘when you have to’’ in the last rule of thumb refers to the observation that passing pointers is often a less obscure mechanism for dealing with objects that need modification (§7.7.1, §7.7.4) than using references.

	12.2.2 Array Arguments

		...an argument of type T[] will be converted to a T∗ when passed as an argument. This implies that an assignment to an element of an array argument changes the value of an element of the argument array. In other words, arrays differ from other types in that an array is not passed by value. Instead, a pointer is passed (by value).
		
		A parameter of array type is equivalent to a parameter of pointer type. For example:
			void odd(int∗ p);
			void odd(int a[]);
			void odd(int buf[1020]);
		
		These three declarations are equivalent and declare the same function. As usual, the argument names do not affect the type of the function (§12.1.3). The rules and techniques for passing multidimensional arrays can be found in §7.4.3.
		
		The size of an array is not available to the called function. This is a major source of errors, but there are several ways of circumventing this problem. C-style strings are zero-terminated, so their size can be computed (e.g., by a potentially expensive call of strlen(); §43.4). For other arrays, a second argument specifying the size can be passed. For example:
			void compute1(int∗ vec_ptr, int vec_size); // one way

		At best, this is a workaround. It is usually preferable to pass a reference to some container, such as vector (§4.4.1, §31.4), array (§34.2.1), or map (§4.4.3, §31.4.3).
		
		If you really want to pass an array, rather than a container or a pointer to the first element of an array, you can declare a parameter of type reference to array. For example:

			void f(int(&r)[4]);

			void g()
			{
				int a1[] = {1,2,3,4};
				int a2[] = {1,2};
				f(a1); // OK
				f(a2); // error: wrong number of elements
			}

		array_reference_parameter.cpp

		Note that the number of elements is part of a reference-to-array type. That makes such references far less flexible than pointers and containers (such as vector). The main use of references to arrays is in templates, where the number of elements is then deduced. For example:
			template<class T, int N> void f(T(&r)[N])
			{
				// ...
			}
			
			int a1[10];
			double a2[100];
			void g()
			{
				f(a1); // T is int; N is 10
				f(a2); // T is double; N is 100
			}
			
		This typically gives rise to as many function definitions as there are calls to f() with distinct array types.
		
		Multidimensional arrays are tricky (see §7.3), but often arrays of pointers can be used instead, and they need no special treatment. For example:
			const char∗ day[] = {
				"mon", "tue", "wed", "thu", "fri", "sat", "sun"
			};

		As ever, vector and similar types are alternatives to the built-in, low-level arrays and pointers.

	12.2.3 List Arguments

		A {}-delimited list can be used as an argument to a parameter of:
			[1] Type std::initializer_list<T> , where the values of the list can be implicitly converted to T
			[2] A type that can be initialized with the values provided in the list
			[3] A reference to an array of T , where the values of the list can be implicitly converted to T
		
		Technically, case [2] covers all examples, but I find it easier to think of the three cases separately. Consider:

			template<class T>
			void f1(initializer_list<T>);
			
			struct S {
				int a;
				string s;
			};
			void f2(S);

			template<class T, int N>
			void f3(T (&r)[N]);
			
			void f4(int);
			
			void g()
			{
				f1({1,2,3,4}); // T is int and the initializer_list has size() 4
				f2({1,"MKS"}); // f2(S{1,"MKS"})
				f3({1,2,3,4}); // T is int and N is 4
				f4({1}); // f4(int{1});
			}
			
		If there is a possible ambiguity, an initializer_list parameter takes priority.

	12.2.4 Unspecified Number of Arguments
		
		For some functions, it is not possible to specify the number and type of all arguments expected in a call. To implement such interfaces, we have three choices:
			[1] Use a variadic template (§28.6): this allows us to handle an arbitrary number of arbitrary types in a type-safe manner by writing a small template metaprogram that interprets the argument list to determine its meaning and take appropriate actions.
			[2] Use an initializer_list as the argument type (§12.2.3). This allows us to handle an arbitrary number of arguments of a single type in a type-safe manner. In many contexts, such homogeneous lists are the most common and important case.
			[3] Terminate the argument list with the ellipsis ( ... ), which means ‘‘and maybe some more arguments.’’ This allows us to handle an arbitrary number of (almost) arbitrary types by using some macros from <cstdarg> . This solution is not inherently type-safe and can be hard to use with sophisticated user-defined types. However, this mechanism has been used from the earliest days of C.
		
		The first two mechanisms are described elsewhere, so I describe only the third mechanism (even though I consider it inferior to the others for most uses). For example:
			int printf(const char∗, ...);
		
		This specifies that a call of the standard-library function printf() (§43.3) must have at least one argument, a C-style string, but may or may not have others. For example:
			printf("Hello, world!\n");
			printf("My name is %s %s\n", first_name , second_name);
			printf("%d + %d = %d\n",2,3,5);
		
		Such a function must rely on information not available to the compiler when interpreting its argument list. In the case of printf() , the first argument is a format string containing special character sequences that allow printf() to handle other arguments correctly; %s means ‘‘expect a char∗ argument’’ and %d means ‘‘expect an int argument.’’ However, the compiler cannot in general ensure that the expected arguments are really provided in a call or that an argument is of the expected type. For example:
			#include <cstdio>
			int main()
			{
				std::printf("My name is %s %s\n",2);
			}
		
		This is not valid code, but most compilers will not catch this error. At best, it will produce some strange-looking output (try it!).

		Clearly, if an argument has not been declared, the compiler does not have the information needed to perform the standard type checking and type conversion for it. In that case, a char or a short is passed as an int and a float is passed as a double. This is not necessarily what the programmer expects.

		lacking_arguments.cpp

		A well-designed program needs at most a few functions for which the argument types are not completely specified. Overloaded functions, functions using default arguments, functions taking initializer_list arguments, and variadic templates can be used to take care of type checking in most cases when one would otherwise consider leaving argument types unspecified. Only when both the number of arguments and the types of arguments vary and a variadic template solution is deemed undesirable is the ellipsis necessary.

		