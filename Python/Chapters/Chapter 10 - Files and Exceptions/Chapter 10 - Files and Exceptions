# Author: Fernando Zuher
# Place: Brazil
# Date: 08 May 2020
# Book: Python Crash Course, 2nd Edition. Author: ERIC MATTHES.
# About: Summary*, Chapter 10 - Files and Exceptions

# Most of the text was drawn literally from the chapter.

Reading from a File
	For example, you can write a program that reads in the contents of a text file and rewrites the file with formatting that allows a browser to display it.

	Reading an Entire File

		with open('pi_digits.txt') as file_object:
			contents = file_object.read()
		print(contents)

		The first line of this program has a lot going on. Let’s start by looking at the open() function. To do any work with a file, even just printing its contents, you first need to open the file to access it. The open() function needs one argument: the name of the file you want to open. Python looks for this file in the directory where the program that’s currently being executed is stored. In this example, file_reader.py is currently running, so Python looks for pi_digits.txt in the directory where file_reader.py is stored. The open() function returns an object representing the file. Here, open('pi_digits.txt') returns an object representing pi_digits.txt. Python assigns this object to file_object, which we’ll work with later in the program.

		The keyword with closes the file once access to it is no longer needed. Notice how we call open() in this program but not close() . You could open and close the file by calling open() and close() , but if a bug in your program prevents the close() method from being executed, the file may never close. This may seem trivial, but improperly closed files can cause data to be lost or corrupted. And if you call close() too early in your program, you’ll find yourself trying to work with a closed file (a file you can’t access), which leads to more errors. It’s not always easy to know exactly when you should close a file, but with the structure shown here, Python will figure that out for you. All you have to do is open the file and work with it as desired, trusting that Python will close it automatically when the with block finishes execution.

		Once we have a file object representing pi_digits.txt, we use the read() method in the second line of our program to read the entire contents of the file and store it as one long string in contents. When we print the value of contents, we get the entire text file back.


	File Paths

		Relative file path.			
			with open('text_files/filename.txt') as file_object:

		Note: Windows systems use a backslash (\) instead of a forward slash (/) when displaying file paths, but you can still use forward slashes in your code.

		Absolute file path. Absolute paths are usually longer than relative paths, so it’s helpful to assign them to a variable and then pass that variable to open():			
			
			file_path = '/home/ehmatthes/other_files/text_files/filename.txt'
			with open(file_path) as file_object:

		Note: If you try to use backslashes in a file path, you’ll get an error because the backslash is used to escape characters in strings. For example, in the path "C:\path\to\file.txt", the sequence \t is interpreted as a tab. If you need to use backslashes, you can escape each one in the path, like this: "C:\\path\\to\\file.txt".


	Reading Line by Line

		filename = 'pi_digits.txt'
		with open(filename) as file_object:
			for line in file_object:
				print(line.rstrip())


	Making a List of Lines from a File

		When you use with, the file object returned by open() is only available inside the with block that contains it. If you want to retain access to a file’s contents outside the with block, you can store the file’s lines in a list inside the block and then work with that list. You can process parts of the file immediately and postpone some processing for later in the program.

			filename = 'pi_digits.txt'
			with open(filename) as file_object:
				lines = file_object.readlines()
			
			for line in lines:
				print(line.rstrip())


	Working with a File’s Contents
		Note: When Python reads from a text file, it interprets all text in the file as a string. If you read in a number and want to work with that value in a numerical context, you’ll have to convert it to an integer using the int() function or convert it to a float using the float() function.

	Large Files: One Million Digits

		filename = 'pi_million_digits.txt'

		with open(filename) as file_object:
			lines = file_object.readlines()
	
		pi_string = ''
		for line in lines:
			pi_string += line.strip()
		
		print(f"{pi_string[:52]}...")
		print(len(pi_string))


Writing to a File

	filename = 'programming.txt'
	with open(filename, 'w') as file_object:
		file_object.write("I love programming.")

	You can open a file in read mode ('r'), write mode ('w'), append mode ('a'), or a mode that allows you to read and write to the file ('r+'). If you omit the mode argument, Python opens the file in read-only mode by default.

	The open() function automatically creates the file you’re writing to if it doesn’t already exist. However, be careful opening a file in write mode ('w') because if the file does exist, Python will erase the contents of the file before returning the file object.

	Note: Python can only write strings to a text file. If you want to store numerical data in a text file, you’ll have to convert the data to string format first using the str() function.

	Writing Multiple Lines
		with open(filename, 'w') as file_object:
			file_object.write("I love programming.\n")
			file_object.write("I love creating new games.\n")

	Appending to a File
		

with open('file.txt') as file_object:
	content = file_object.read()

	lines = file_object.readlines()

int()
float()
str()
string_replaced = string.replace('abc', 'def')

with open('output.txt', 'w') as file_object:
	file_object.write("I love programming.")

read mode ('r'), write mode ('w'), append mode ('a'), read and write to the file ('r+')

--------------------
Exceptions

try-except-else

"The only code that should go in a try block is code
that might cause an exception to be raised. Sometimes you’ll have addi-
tional code that should run only if the try block was successful; this code
goes in the else block. The except block tells Python what to do in case a
certain exception arises when it tries to run the code in the try block."

Exceptions:
ZeroDivisionError
FileNotFoundError
ValueError

lista_de_palavras_da_string = string.split()

except FileNotFoundError:
	pass

"Giving users information they aren’t looking for can decrease the
usability of your program. Python’s error-handling structures give you fine-
grained control over how much to share with users when things go wrong;
it’s up to you to decide how much information to share.

Well-written, properly tested code is not very prone to internal errors,
such as syntax or logical errors. But every time your program depends on
something external, such as user input, the existence of a file, or the avail-
ability of a network connection, there is a possibility of an exception being
raised. A little experience will help you know where to include exception
handling blocks in your program and how much to report to users about
errors that arise.
"

quantidade = linha.count('palavra')

------------------------------
STORE DATA

import json

json.dump(data-structure, file_object)
content = json.load(file_object)


REFACTORING
"...This compartmentalization of work is an essential part of writing
clear code that will be easy to maintain and extend."

