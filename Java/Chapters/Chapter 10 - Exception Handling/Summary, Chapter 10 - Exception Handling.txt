/*
Author: Fernando Zuher
Place: Brazil
Date: 02 June 2020
Book: Java The Complete Reference, 11th Edition. Author: Herbert Schildt.
About: Summary*, Chapter 10 - Exception Handling

* Most of the written is taken literally from the chapter.

*/

An exception is an abnormal condition that arises in a code sequence at run time. In other words, an exception is a run-time error. In computer languages that do not support exception handling, errors must be checked and handled manually—typically through the use of error codes, and so on. This approach is as cumbersome as it is troublesome. Java’s exception handling avoids these problems and, in the process, brings run-time error management into the object-oriented world.

-------------------------------
Exception-Handling Fundamentals

	A Java exception is an object that describes an exceptional (that is, error) condition that has occurred in a piece of code. When an exceptional condition arises, an object representing that exception is created and thrown in the method that caused the error. That method may choose to handle the exception itself, or pass it on. Either way, at some point, the exception is caught and processed. Exceptions can be generated by the Java run-time system, or they can be manually generated by your code. Exceptions thrown by Java relate to fundamental errors that violate the rules of the Java language or the constraints of the Java execution environment. Manually generated exceptions are typically used to report some error condition to the caller of a method. 
	
	Java exception handling is managed via five keywords: try, catch, throw, throws, and finally.

---------------
Exception Types

	All exception types are subclasses of the built-in class Throwable. Thus, Throwable is at the top of the exception class hierarchy. Immediately below Throwable are two subclasses that partition exceptions into two distinct branches. One branch is headed by Exception. This class is used for exceptional conditions that user programs should catch. This is also the class that you will subclass to create your own custom exception types. There is an important subclass of Exception, called RuntimeException. Exceptions of this type are automatically defined for the programs that you write and include things such as division by zero and invalid array indexing.

	The other branch is topped by Error, which defines exceptions that are not expected to be caught under normal circumstances by your program. Exceptions of type Error are used by the Java run-time system to indicate errors having to do with the run-time environment, itself. Stack overflow is an example of such an error. This chapter will not be dealing with exceptions of type Error, because these are typically created in response to catastrophic failures that cannot usually be handled by your program.

--------------------
Uncaught Exceptions

	When the Java run-time system detects the attempt to divide by zero, it constructs a new exception object and then throws this exception. This causes the execution of Exc0 to stop, because once an exception has been thrown, it must be caught by an exception handler and dealt with immediately. In thisexample, we haven’t supplied any exception handlers of our own, so the exception is caught by the default handler provided by the Java run-time system. Any exception that is not caught by your program will ultimately be processed by the default handler. The default handler displays a string describing the exception, prints a stack trace from the point at which the exception occurred, and terminates the program.

	The call stack is quite useful for debugging, because it pinpoints the precise sequence of steps that led to the error.

----------------------------------------
Displaying a Description of an Exception

	Throwable overrides the toString( ) method (defined by Object) so that it returns a string containing a description of the exception. You can display this description in a println( ) statement by simply passing the exception as an argument.

	catch (ArithmeticException e) {
		System.out.println("Exception: " + e);
	}

	While it is of no particular value in this context, the ability to display a description of an exception is valuable in other circumstances—particularly when you are experimenting with exceptions or when you are debugging.

----------------------
Multiple catch Clauses

	When you use multiple catch statements, it is important to remember that exception subclasses must come before any of their superclasses. This is because a catch statement that uses a superclass will catch exceptions of that type plus any of its subclasses. Thus, a subclass would never be reached if it came after its superclass. Further, in Java, unreachable code is an error.

	If you try to compile this program

		... (page 379)

	, you will receive an error message stating that the second catch statement is unreachable because the exception has already been caught. Since ArithmeticException is a subclass of Exception, the first catch statement will handle all Exception-based errors, including ArithmeticException. This means that the second catch statement will never execute. To fix the problem, reverse the order of the catch statements.

---------------------
Nested try Statements

---------------------
throw

	So far, you have only been catching exceptions that are thrown by the Java runtime system. However, it is possible for your program to throw an exception explicitly, using the throw statement. The general form of throw is shown here:
		
		throw ThrowableInstance;

	Here, ThrowableInstance must be an object of type Throwable or a subclass of Throwable. Primitive types, such as int or char, as well as non-Throwable classes, such as String and Object, cannot be used as exceptions. There are two ways you can obtain a Throwable object: using a parameter in a catch clause or creating one with the new operator.

	The flow of execution stops immediately after the throw statement; any subsequent statements are not executed.

		try {
			try {
				throw new NullPointerException("demo");
			}
			catch (NullPointerException e) {
				System.out.println("...");
				throw e;
			}
		}
		catch (NullPointerException e) {
			System.out.println("Recaught: " + e); // Recaught: java.lang.NullPointerException: demo
		}


	The program also illustrates how to create one of Java’s standard exception objects. Pay close attention to this line:
		
		throw new NullPointerException("demo");
	
	Here, new is used to construct an instance of NullPointerException. Many of Java’s built-in run-time exceptions have at least two constructors: one with no parameter and one that takes a string parameter. When the second form is used, the argument specifies a string that describes the exception. This string is displayed when the object is used as an argument to print() or println(). It can also be obtained by a call to getMessage(), which is defined by Throwable.

------
throws

	If a method is capable of causing an exception that it does not handle, it must specify this behavior so that callers of the method can guard themselves against that exception. You do this by including a throws clause in the method’s declaration. A throws clause lists the types of exceptions that a method might throw. This is necessary for all exceptions, except those of type Error or RuntimeException, or any of their subclasses. All other exceptions that a method can throw must be declared in the throws clause. If they are not, a compile-time error will result. 

		***I did like the above and it compiled in the same way. So?
			It works just with non checked Exception classes. With new ones it is necessary the above statement.

		void aFunction() throws SomeException {
			...
			throw new SomeException();
		}

-------
finally
	
	finally creates a block of code that will be executed after a try /catch block has completed and before the code following the try/catch block. The finally block will execute whether or not an exception is thrown. If an exception is thrown, the finally block will execute even if no catch statement matches the exception. Any time a method is about to return to the caller from inside a try/catch block, via an uncaught exception or an explicit return statement, the finally clause is also executed just before the method returns. This can be useful for closing file handles and freeing up any other resources that might have been allocated at the beginning of a method with the intent of disposing of them before returning. The finally clause is optional. However, each try statement requires at least one catch or a finally clause.

Java’s Built-in Exceptions

	Inside the standard package java.lang, Java defines several exception classes. A few have been used by the preceding examples. The most general of these exceptions are subclasses of the standard type RuntimeException. As previously explained, these exceptions need not be included in any method’s throws list. In the language of Java, these are called unchecked exceptions because the compiler does not check to see if a method handles or throws these exceptions. The unchecked exceptions defined in java.lang are listed in Table 10-1. Table 10-2 lists those exceptions defined by java.lang that must be included in a method’s throws list if that method can generate one of these exceptions and does not handle it itself. These are called checked exceptions. In addition to the exceptions in java .lang, Java defines several more that relate to its other standard packages.

---------------------------------------
Creating Your Own Exception Subclasses

	Although Java’s built-in exceptions handle most common errors, you will probably want to create your own exception types to handle situations specific to your applications. This is quite easy to do: just define a subclass of Exception (which is, of course, a subclass of Throwable). Your subclasses don’t need to actually implement anything—it is their existence in the type system that allows you to use them as exceptions.

	The Exception class does not define any methods of its own. It does, of course, inherit those methods provided by Throwable. Thus, all exceptions, including those that you create, have the methods defined by Throwable available to them. They are shown in Table 10-3. You may also wish to override one or more of these methods in exception classes that you create.

	Exception defines four public constructors. Two support chained exceptions, described in the next section. The other two are shown here:
		Exception()
		Exception(String msg)

	The first form creates an exception that has no description. The second form lets you specify a description of the exception.

	Although specifying a description when an exception is created is often useful, sometimes it is better to override toString(). Here’s why: The version of toString() defined by Throwable (and inherited by Exception) first displays the name of the exception followed by a colon, which is then followed by your description. By overriding toString(), you can prevent the exception name and colon from being displayed. This makes for a cleaner output, which is desirable in some cases.

	The following example declares a new subclass of Exception and then uses that subclass to signal an error condition in a method. It overrides the toString() method, allowing a carefully tailored description of the exception to be displayed.

------------------
Chained Exceptions

	The chained exception feature allows you to associate another exception with an exception. This second exception describes the cause of the first exception.

-----------------------------------
Three Additional Exception Features

	The multi-catch feature allows two or more exceptions to be caught by the same catch clause.

	To use a multi-catch, separate each exception type in the catch clause with the OR operator. Each multi-catch parameter is implicitly final. (You can explicitly specify final, if desired, but it is not necessary.) Because each multicatch parameter is implicitly final, it can’t be assigned a new value.

		catch(ArithmeticException | ArrayIndexOutOfBoundsException e)

---------------------
Using Exceptions

	Exception handling provides a powerful mechanism for controlling complex programs that have many dynamic run-time characteristics. It is important to think of try, throw, and catch as clean ways to handle errors and unusual boundary conditions in your program’s logic. Instead of using error return codes to indicate failure, use Java’s exception handling capabilities. Thus, when a method can fail, have it throw an exception. This is a cleaner way to handle failure modes.


EXCEPTIONS:
	
	Exception	
		ArithmeticException
		ArrayIndexOutOfBoundsException