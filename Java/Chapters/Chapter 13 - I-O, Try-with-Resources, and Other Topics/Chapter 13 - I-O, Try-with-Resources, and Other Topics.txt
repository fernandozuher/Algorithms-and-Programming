/*
Author: Fernando Zuher
Place: Brazil
Date: 03 July 2020
Book: Java The Complete Reference, 11th Edition. Author: Herbert Schildt.
About: Summary*, Chapter 13 - I/O, Try-with-Resources, and Other Topics

* Most of the text was drawn literally from the chapter.

Pages 

*/

This chapter introduces one of Java’s most important packages, java.io, which supports Java’s basic I/O (input/output) system, including file I/O. Support for I/O comes from Java’s core API libraries, not from language keywords. For this reason, an in-depth discussion of this topic is found in Part II of this book, which examines several of Java’s API packages. Here, the foundation of this important subsystem is introduced so that you can see how it fits into the larger context of the Java programming and execution environment. This chapter also examines the try-with-resources statement and several more Java keywords: transient, volatile, instanceof, native, strictfp, and assert. It concludes by discussing static import and describing another use for the this keyword.

I/O Basics

	As you may have noticed while reading the preceding 12 chapters, not much use has been made of I/O in the example programs. In fact, aside from print() and println(), none of the I/O methods have been used significantly. The reason is simple: most real applications of Java are not text-based, console programs. Rather, they are either graphically oriented programs that rely on one of Java’s graphical user interface (GUI) frameworks, such as Swing, the AWT, or JavaFX, for user interaction, or they are Web applications. Although text-based, console programs are excellent as teaching examples, they do not, as a general rule, constitute an important use for Java in the real world. Also, Java’s support for console I/O is limited and somewhat awkward to use—even in simple example programs. Text-based console I/O is just not that useful in real-world Java programming.

	The preceding paragraph notwithstanding, Java does provide strong, flexible support for I/O as it relates to files and networks. Java’s I/O system is cohesive and consistent. In fact, once you understand its fundamentals, the rest of the I/O system is easy to master. A general overview of I/O is presented here. A detailed description is found in Chapters 21 and 22.

	Streams

		Java programs perform I/O through streams. A stream is an abstraction that either produces or consumes information. A stream is linked to a physical device by the Java I/O system. All streams behave in the same manner, even if the actual physical devices to which they are linked differ. Thus, the same I/O classes and methods can be applied to different types of devices. This means that an input stream can abstract many different kinds of input: from a disk file, a keyboard, or a network socket. Likewise, an output stream may refer to the console, a disk file, or a network connection. Streams are a clean way to deal with input/output without having every part of your code understand the difference between a keyboard and a network, for example. Java implements streams within class hierarchies defined in the java.io package.

		NOTE In addition to the stream-based I/O defined in java.io, Java also provides buffer- and channel-based I/O, which is defined in java.nio and its subpackages. They are described in Chapter 22.

		Byte Streams and Character Streams

			Java defines two types of streams: byte and character. Byte streams provide a convenient means for handling input and output of bytes. Byte streams are used, for example, when reading or writing binary data. Character streams provide a convenient means for handling input and output of characters. They use Unicode and, therefore, can be internationalized. Also, in some cases, character streams are more efficient than byte streams.

			One other point: at the lowest level, all I/O is still byte-oriented. The character-based streams simply provide a convenient and efficient means for handling characters.

			An overview of both byte-oriented streams and character-oriented streams is presented in the following sections.

			The Byte Stream Classes

				Byte streams are defined by using two class hierarchies. At the top are two abstract classes: InputStream and OutputStream. Each of these abstract classes has several concrete subclasses that handle the differences among various devices, such as disk files, network connections, and even memory buffers. The byte stream classes in java.io are shown in Table 13-1. A few of these classes are discussed later in this section. Others are described in Part II of this book. Remember, to use the stream classes, you must import java.io.

					Table 13-1 The Byte Stream Classes in java.io

				The abstract classes InputStream and OutputStream define several keymethods that the other stream classes implement. Two of the most important are read() and write(), which, respectively, read and write bytes of data. Each has a form that is abstract and must be overridden by derived stream classes.

			The Character Stream Classes

				Character streams are defined by using two class hierarchies. At the top are two abstract classes: Reader and Writer. These abstract classes handle Unicode character streams. Java has several concrete subclasses of each of these. The character stream classes in java.io are shown in Table 13-2.

					Table 13-2 The Character Stream I/O Classes in java.io

				The abstract classes Reader and Writer define several key methods that theother stream classes implement. Two of the most important methods are read() and write(), which read and write characters of data, respectively. Each has a form that is abstract and must be overridden by derived stream classes.

		The Predefined Streams

			As you know, all Java programs automatically import the java.lang package. This package defines a class called System, which encapsulates several aspects of the run-time environment. For example, using some of its methods, you can obtain the current time and the settings of various properties associated with the system. System also contains three predefined stream variables: in, out, and err. These fields are declared as public, static, and final within System. This means that they can be used by any other part of your program and without reference to a specific System object.

			System.out refers to the standard output stream. By default, this is the console. System.in refers to standard input, which is the keyboard by default. System.err refers to the standard error stream, which also is the console by default. However, these streams may be redirected to any compatible I/O device. 

			System.in is an object of type InputStream; System.out and System.err are objects of type PrintStream. These are byte streams, even though they are typically used to read and write characters from and to the console. As you will see, you can wrap these within character-based streams, if desired.

			The preceding chapters have been using System.out in their examples. You can use System.err in much the same way. As explained in the next section, use of System.in is a little more complicated.

	Reading Console Input

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		After this statement executes, br is a character-based stream that is linked to the console through System.in.

		Reading Characters

			To read a character from a BufferedReader, use read(). The version of read() that we will be using is
			
				int read() throws IOException 
			
			Each time that read() is called, it reads a character from the input stream and returns it as an integer value. It returns –1 when an attempt is made to read at the end of the stream.

			BRRead.java

		Reading Strings

			To read a string from the keyboard, use the version of readLine() that is a member of the BufferedReader class. Its general form is shown here:
			
				String readLine() throws IOException

			BRReadLines.java

	Writing Console Output

		Console output is most easily accomplished with print() and println(), described earlier, which are used in most of the examples in this book. These methods are defined by the class PrintStream (which is the type of object referenced by System.out). Even though System .out is a byte stream, using it for simple program output is still acceptable. However, a character-based alternative is described in the next section.

		Because PrintStream is an output stream derived from OutputStream, it also implements the low-level method write(). Thus, write() can be used to write to the console. The simplest form of write() defined by PrintStream is shown here:
			
			void write(int byteval)

		This method writes the byte specified by byteval. Although byteval is declared as an integer, only the low-order eight bits are written. Here is a short example that uses write() to output the character "A" followed by a newline to the screen:

			WriteDemo.java

		You will not often use write() to perform console output (although doing so might be useful in some situations) because print() and println() are substantially easier to use.

		The PrintWriter Class

			Although using System.out to write to the console is acceptable, its use is probably best for debugging purposes or for sample programs, such as those found in this book. For real-world programs, the recommended method ofwriting to the console when using Java is through a PrintWriter stream. PrintWriter is one of the character-based classes. Using a character-based class for console output makes internationalizing your program easier.
			
			PrintWriter defines several constructors. The one we will use is shown here:

				PrintWriter(OutputStream outputStream, boolean flushingOn)

			Here, outputStream is an object of type OutputStream, and flushingOn controls whether Java flushes the output stream every time a println() method (among others) is called. If flushingOn is true, flushing automatically takes place. If false, flushing is not automatic.

			PrintWriter supports the print() and println() methods. Thus, you can use these methods in the same way as you used them with System.out. If an argument is not a simple type, the PrintWriter methods call the object’s toString() method and then display the result.

			To write to the console by using a PrintWriter, specify System.out for the output stream and automatic flushing. For example, this line of code creates a PrintWriter that is connected to console output:
				
				PrintWriter pw = new PrintWriter(System.out, true);

			PrintWriterDemo.java

			Remember, there is nothing wrong with using System.out to write simple text output to the console when you are learning Java or debugging your programs. However, using a PrintWriter makes your real-world applications easier to internationalize. Because no advantage is gained by using a PrintWriter in the sample programs shown in this book, we will continue to use System.out to write to the console.

	Reading and Writing Files

		Two of the most often-used stream classes are FileInputStream and FileOutputStream, which create byte streams linked to files. To open a file, you simply create an object of one of these classes, specifying the name of the file as an argument to the constructor. Although both classes support additional constructors, the following are the forms that we will be using: 
			
			FileInputStream(String fileName) throws FileNotFoundException
			FileOutputStream(String fileName) throws FileNotFoundException

		FileNotFoundException is a subclass of IOException. When an output file is opened, any preexisting file by the same name is destroyed.

		When you are done with a file, you must close it. This is done by calling the close() method, which is implemented by both FileInputStream and FileOutputStream. It is shown here:
			void close() throws IOException
		Closing a file releases the system resources allocated to the file, allowing them to be used by another file. Failure to close a file can result in “memory leaks” because of unused resources remaining allocated.

		NOTE The close() method is specified by the AutoCloseable interface in java.lang. AutoCloseable is inherited by the Closeable interface in java.io. Both interfaces are implemented by the stream classes, including FileInputStream and FileOutputStream.

		Before moving on, it is important to point out that there are two basic approaches that you can use to close a file when you are done with it. The first is the traditional approach, in which close() is called explicitly when the file is no longer needed. This is the approach used by all versions of Java prior to JDK 7 and is, therefore, found in all pre-JDK 7 legacy code. The second is to use the try-with-resources statement added by JDK 7, which automatically closes a file when it is no longer needed. In this approach, no explicit call to close() is executed. Since you may still encounter pre-JDK 7 legacy code, it is important that you know and understand the traditional approach. Furthermore, the traditional approach could still be the best approach in some situations.

		To read from a file, you can use a version of read() that is defined within FileInputStream. The one that we will use is shown here:
			int read() throws IOException
		
		Each time that it is called, it reads a single byte from the file and returns the byte as an integer value. read() returns –1 when an attempt is made to read at the end of the stream. It can throw an IOException.
		
		The following program uses read( ) to input and display the contents of a file that contains ASCII text. The name of the file is specified as a command-line argument.

		ShowFile.java

		Although the preceding example closes the file stream after the file is read, there is a variation that is often useful. The variation is to call close() within a finally block. In this approach, all of the methods that access the file are contained within a try block, and the finally block is used to close the file. This way, no matter how the try block terminates, the file is closed. Assuming the preceding example, here is how the try block that reads the file can be recoded:
		
			ShowFileFinally.java

		Although not an issue in this case, one advantage to this approach in general is that if the code that accesses a file terminates because of some non-I/O related exception, the file is still closed by the finally block.

		Sometimes it’s easier to wrap the portions of a program that open the file and access the file within a single try block (rather than separating the two) and then use a finally block to close the file. For example, here is another way to write the ShowFile program:

			ShowFileFinally2.java
			ShowFileFinally3.java

		To write to a file, you can use the write() method defined by FileOutputStream. Its simplest form is shown here:
			void write(int byteval) throws IOException

		This method writes the byte specified by byteval to the file. Although byteval is declared as an integer, only the low-order eight bits are written to the file. If an error occurs during writing, an IOException is thrown. The next example uses write() to copy a file:

			CopyFile.java

		In the program, notice that two separate try blocks are used when closing the files. This ensures that both files are closed, even if the call to fin.close() throws an exception.

		In general, notice that all potential I/O errors are handled in the preceding two programs by the use of exceptions. This differs from some computer languages that use error codes to report file errors. Not only do exceptions make file handling cleaner, but they also enable Java to easily differentiate the end-of-file condition from file errors when input is being performed.

	Automatically Closing a File

		This feature, sometimes referred to as automatic resource management, or ARM for short, is based on an expanded version of the try statement. The principal advantage of automatic resource management is that it prevents situations in which a file (or other resource) is inadvertently not released after it is no longer needed. As explained, forgetting to close a file can result in memory leaks, and could lead to other problems.

		Automatic resource management is based on an expanded form of the try statement. Here is its general form:

			try (resource-specification) {
				// use the resource
			}

		Typically, resource-specification is a statement that declares and initializes a resource, such as a file stream. It consists of a variable declaration in which the variable is initialized with a reference to the object being managed. When the try block ends, the resource is automatically released. In the case of a file, this means that the file is automatically closed. (Thus, there is no need to call close() explicitly.) Of course, this form of try can also include catch and finally clauses. This form of try is called the try-with-resources statement.

		NOTE Beginning with JDK 9, it is also possible for the resource specification of the try to consist of a variable that has been declared and initialized earlier in the program. However, that variable must be effectively final, which means that it has not been assigned a new value after being given its initial value.

		The try-with-resources statement can be used only with those resources that implement the AutoCloseable interface defined by java.lang. This interface defines the close() method. AutoCloseable is inherited by the Closeable interface in java.io. Both interfaces are implemented by the stream classes. Thus, try-with-resources can be used when working with streams, including file streams.

		ShowFileResources.java

		It is important to understand that a resource declared in the try statement is implicitly final. This means that you can’t assign to the resource after it has been created. Also, the scope of the resource is limited to the try-with-resources statement.

		Before moving on it is useful to mention that beginning with JDK 10, you can use local variable type inference to specify the type of the resource declared in a try-with-resources statement. To do so, specify the type as var. When this is done, the type of the resource is inferred from its initializer. For example, the try statement in the preceding program can now be written like this:
			try(var fin = new FileInputStream(args[0])) {
		Here, fin is inferred to be of type FileInputStream because that is the type of its initializer.

		You can manage more than one resource within a single try statement. To do so, simply separate each resource specification with a semicolon. The following program shows an example. It reworks the CopyFile program shown earlier so that it uses a single try-with-resources statement to manage both fin and fout.

		CopyFileResources.java

		There is one other aspect to try-with-resources that needs to be mentioned. In general, when a try block executes, it is possible that an exception inside the try block will lead to another exception that occurs when the resource is closed in a finally clause. In the case of a “normal” try statement, the original exception is lost, being preempted by the second exception. However, when using try-with-resources, the second exception is suppressed. It is not, however, lost. Instead, it is added to the list of suppressed exceptions associated with the first exception. The list of suppressed exceptions can be obtained by using the getSuppressed() method defined by Throwable.

		



