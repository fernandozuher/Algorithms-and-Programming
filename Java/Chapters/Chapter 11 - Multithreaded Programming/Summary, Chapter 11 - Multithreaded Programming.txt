/*
Author: Fernando Zuher
Place: Brazil
Date: 19 June 2020
Book: Java The Complete Reference, 11th Edition. Author: Herbert Schildt.
About: Summary*, Chapter 11 - Multithreaded Programming

* Most of the text was drawn literally from the chapter.

*/

Java provides built-in support for multithreaded programming. A multithreaded
program contains two or more parts that can run concurrently. Each part of such
a program is called a thread, and each thread defines a separate path of
execution. Thus, multithreading is a specialized form of multitasking.

...there are two distinct types
of multitasking: process-based and thread-based. It is important to understand
the difference between the two. For many readers, process-based multitasking is
the more familiar form. A process is, in essence, a program that is executing.
Thus, process-based multitasking is the feature that allows your computer to run
two or more programs concurrently. For example, process-based multitasking
enables you to run the Java compiler at the same time that you are using a text
editor or visiting a web site. In process-based multitasking, a program is the
smallest unit of code that can be dispatched by the scheduler.
In a thread-based multitasking environment, the thread is the smallest unit of
dispatchable code. This means that a single program can perform two or more
tasks simultaneously. For instance, a text editor can format text at the same time
that it is printing, as long as these two actions are being performed by two
separate threads. Thus, process-based multitasking deals with the “big picture,”
and thread-based multitasking handles the details.

The Java Thread Model

	Threads exist in several states. Here is a general description. A thread can be
	running. It can be ready to run as soon as it gets CPU time. A running thread can
	be suspended, which temporarily halts its activity. A suspended thread can then
	be resumed, allowing it to pick up where it left off. A thread can be blocked
	when waiting for a resource. At any time, a thread can be terminated, which
	halts its execution immediately. Once terminated, a thread cannot be resumed.

	Thread Priorities
		
		Java assigns to each thread a priority that determines how that thread should be
		treated with respect to the others. Thread priorities are integers that specify the
		relative priority of one thread to another. As an absolute value, a priority is
		meaningless; a higher-priority thread doesn’t run any faster than a lower-priority
		thread if it is the only thread running. Instead, a thread’s priority is used to
		decide when to switch from one running thread to the next. This is called a
		context switch.

		CAUTION Portability problems can arise from the differences in the way that operating systems context-
		switch threads of equal priority.

	Synchronization

		Because multithreading introduces an asynchronous behavior to your programs,
		there must be a way for you to enforce synchronicity when you need it. For
		example, if you want two threads to communicate and share a complicated data
		structure, such as a linked list, you need some way to ensure that they don’t
		conflict with each other. That is, you must prevent one thread from writing data
		while another thread is in the middle of reading it. For this purpose, Java
		implements an elegant twist on an age-old model of interprocess
		synchronization: the monitor. The monitor is a control mechanism first defined
		by C.A.R. Hoare. You can think of a monitor as a very small box that can hold
		only one thread. Once a thread enters a monitor, all other threads must wait until
		that thread exits the monitor. In this way, a monitor can be used to protect a
		shared asset from being manipulated by more than one thread at a time.

		In Java, there is no class “Monitor”; instead, each object has its own implicit
		monitor that is automatically entered when one of the object’s synchronized
		methods is called. Once a thread is inside a synchronized method, no other
		thread can call any other synchronized method on the same object. This enables
		you to write very clear and concise multithreaded code, because synchronization
		support is built into the language.

	Messaging

		After you divide your program into separate threads, you need to define how
		they will communicate with each other. When programming with some other
		languages, you must depend on the operating system to establish communication
		between threads. This, of course, adds overhead. By contrast, Java provides a
		clean, low-cost way for two or more threads to talk to each other, via calls to
		predefined methods that all objects have. Java’s messaging system allows a
		thread to enter a synchronized method on an object, and then wait there until
		some other thread explicitly notifies it to come out.

	The Thread Class and the Runnable Interface
	
		Java’s multithreading system is built upon the Thread class, its methods, and its
		companion interface, Runnable. Thread encapsulates a thread of execution.
		Since you can’t directly refer to the ethereal state of a running thread, you will
		deal with it through its proxy, the Thread instance that spawned it. To create a
		new thread, your program will either extend Thread or implement the
		Runnable interface.

		The Thread class defines several methods that help manage threads. Several
		of those used in this chapter are shown here:
			getName()
			getPriority()
			isAlive()
			join()
			run()
			sleep()
			start()

	The Main Thread

		When a Java program starts up, one thread begins running immediately. This is
		usually called the main thread of your program, because it is the one that is
		executed when your program begins. The main thread is important for two
		reasons:
			• It is the thread from which other “child” threads will be spawned.
			• Often, it must be the last thread to finish execution because it performs
			various shutdown actions.
			
		Although the main thread is created automatically when your program is
		started, it can be controlled through a Thread object. To do so, you must obtain
		a reference to it by calling the method currentThread( ), which is a public
		static member of Thread. Its general form is shown here:
			
			static Thread currentThread()
		
		This method returns a reference to the thread in which it is called. Once you
		have a reference to the main thread, you can control it just like any other thread.





		static void sleep(long milliseconds) throws InterruptedException

		The sleep( ) method has a second form, shown next, which allows you to
		specify the period in terms of milliseconds and nanoseconds:
		static void sleep(long milliseconds, int nanoseconds) throws
		InterruptedException
		This second form is useful only in environments that allow timing periods as
		short as nanoseconds.

		final void setName(String threadName)
		final String getName( )

Creating a Thread
	
	In the most general sense, you create a thread by instantiating an object of type
	Thread. Java defines two ways in which this can be accomplished:
		• You can implement the Runnable interface.
		• You can extend the Thread class, itself.

